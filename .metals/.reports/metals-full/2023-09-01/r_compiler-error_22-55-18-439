java.lang.IndexOutOfBoundsException: 0
occurred in the presentation compiler.

action parameters:
offset: 2311
uri: file://<WORKSPACE>/npc/playground/test/src/WallaceTest.scala
text:
import chisel3._
import chisel3.util._
import chiseltest._
import chisel3.experimental.BundleLiterals._
import chiseltest.formal._
import chiseltest.formal.BoundedCheck
import utest._

class HA extends Module{
  val io=IO(new Bundle{
    val in = Input(Vec(2,Bool()))
    val out = Output(Vec(2,Bool()))
  })

  io.out(1) := io.in(0) ^ io.in(1)  //cout
  io.out(0) := io.in(0) & io.out(1) //sum
  
}

class FA extends Module{
  val io=IO(new Bundle{
    val in = Input(Vec(3,Bool()))
    val out = Output(Vec(2,Bool()))
  })

  io.out(1) := (io.in(0) & io.in(1)) | (io.in(2) & (io.in(0) ^ io.in(1))) //cout
  io.out(0) := io.in(0) ^ io.in(1) ^ io.in(2)                             //sum
}

class gen_p_i extends Module{
  val io=IO(new Bundle{
    val x=Input(Bool())
    val x_sub=Input(Bool())
    val sel=Input(UInt(4.W))
    val p=Output(Bool())
  })
  val sel_negative=io.sel(0)
  val sel_positive=io.sel(1)
  val sel_double_negative=io.sel(2)
  val sel_double_positive=io.sel(3)

  io.p := ~(~(sel_negative & ~io.x) & ~(sel_double_negative & ~io.x_sub) 
          & ~(sel_positive & io.x ) & ~(sel_double_positive &  io.x_sub));
}

class gen_sel extends Module {
  val io = IO(new Bundle {
    val src = Input(UInt(3.W))
    val out=Output(UInt(4.W))
  })

  val y_sub = io.src(0)
  val y =io.src(1)
  val y_add =io.src(2)

  val sel_negative = (y_add & (y & ~y_sub | ~y & y_sub)).asUInt()
  val sel_positive = (~y_add & (y & ~y_sub | ~y & y_sub)).asUInt()
  val sel_double_negative = (y_add & ~y & ~y_sub).asUInt()
  val sel_double_positive = (~y_add & y & y_sub).asUInt()

  io.out:=Cat(sel_double_positive,sel_double_negative,sel_positive,sel_negative)
}

class gen_p extends Module{
  val io=IO(new Bundle{
    val src=Input(UInt(3.W))
    val x = Input(UInt(132.W))
    val p=Output(UInt(132.W))
    val c=Output(UInt(1.W))
  })

  val sel=Module(new gen_sel).io
  val p=Vec(132,Module(new gen_p_i).io)

  sel.src:=io.src
  for(i <- 0 to 132){
    p(i).x:= io.x(i)
    if(i>0){
      p(i).x_sub := io.x(i-1)
    }
    else{
      p(i).x_sub := 0.U
    }
    p(i).sel:=sel.out
  }
  
  io.p :=Cat(p.map(_.x.asUInt()))
  io.c :=sel.out(0) | sel.out(2)//-x or -2x
}

class switch extends Module{
  val io=IO(new Bundle{
    val in=Input(Vec(33,UInt(132.W)))
    val out=Output(Vec(132,33.W))
  })
  for(@@)
}
class Wallace extends Module{
  val io=IO(new Bundle{
      val mul_valid = Input(UInt(1.W))         //为高表示输入的数据有效，如果没有新的乘法输入，在乘法被接受的下一个周期要置低
      val flush= Input(UInt(1.W))              //为高表示取消乘法
      val mulw= Input(UInt(1.W))               //为高表示是 32 位乘法
      val mul_signed= Input(UInt(2.W))         //2’b11（signed x signed）；2’b10（signed x unsigned）；2’b00（unsigned x unsigned）；
      val multiplicand= Input(UInt(64.W))      //被乘数，64 表示乘法器位数
      val multiplier= Input(UInt(64.W))        //乘数
      val mul_ready= Output(UInt(1.W))         //为高表示乘法器准备好，表示可以输入数据
      val out_valid= Output(UInt(1.W))         //为高表示乘法器输出的结果有效
      val result_hi= Output(UInt(64.W))        //高 64 bits 结果
      val result_lo= Output(UInt(64.W))        //低 64 bits 结果
  })



}



object Wallace extends TestSuite {
  val tests: Tests = Tests {
    test("mytest") {
      new Formal with HasTestName {
        def getTestName: String = s"Wallace"
      }.verify(new Wallace, Seq(BoundedCheck(1)))
    }
  }
}


error stacktrace:
scala.collection.LinearSeqOps.apply(LinearSeq.scala:131)
	scala.collection.LinearSeqOps.apply$(LinearSeq.scala:128)
	scala.collection.immutable.List.apply(List.scala:79)
	dotty.tools.dotc.util.Signatures$.countParams(Signatures.scala:501)
	dotty.tools.dotc.util.Signatures$.applyCallInfo(Signatures.scala:186)
	dotty.tools.dotc.util.Signatures$.computeSignatureHelp(Signatures.scala:94)
	dotty.tools.dotc.util.Signatures$.signatureHelp(Signatures.scala:63)
	scala.meta.internal.pc.MetalsSignatures$.signatures(MetalsSignatures.scala:17)
	scala.meta.internal.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:51)
	scala.meta.internal.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:371)
