java.lang.IndexOutOfBoundsException: 0
occurred in the presentation compiler.

action parameters:
offset: 3611
uri: file://<WORKSPACE>/npc/playground/test/src/WallaceTest.scala
text:
import chisel3._
import chisel3.util._
import chiseltest._
import chisel3.experimental.BundleLiterals._
import chiseltest.formal._
import chiseltest.formal.BoundedCheck
import utest._

class HA extends Module{
  val io=IO(new Bundle{
    val in = Input(Vec(2,Bool()))
    val out = Output(Vec(2,Bool()))
  })

  io.out(1) := io.in(0) ^ io.in(1)  //cout
  io.out(0) := io.in(0) & io.out(1) //sum
  
}

class CSA extends Module{
  val io=IO(new Bundle{
    val in = Input(Vec(3,Bool()))
    val out = Output(Vec(2,Bool()))
  })

  io.out(1) := (io.in(0) & io.in(1)) | (io.in(2) & (io.in(0) ^ io.in(1))) //cout
  io.out(0) := io.in(0) ^ io.in(1) ^ io.in(2)                             //sum
}

class gen_p_i extends Module{
  val io=IO(new Bundle{
    val x=Input(Bool())
    val x_sub=Input(Bool())
    val sel=Input(UInt(4.W))
    val p=Output(Bool())
  })
  val sel_negative=io.sel(0)
  val sel_positive=io.sel(1)
  val sel_double_negative=io.sel(2)
  val sel_double_positive=io.sel(3)

  io.p := ~(~(sel_negative & ~io.x) & ~(sel_double_negative & ~io.x_sub) 
          & ~(sel_positive & io.x ) & ~(sel_double_positive &  io.x_sub));
}

class gen_sel extends Module {
  val io = IO(new Bundle {
    val src = Input(UInt(3.W))
    val out=Output(UInt(4.W))
  })

  val y_sub = io.src(0)
  val y =io.src(1)
  val y_add =io.src(2)

  val sel_negative = (y_add & (y & ~y_sub | ~y & y_sub)).asUInt()
  val sel_positive = (~y_add & (y & ~y_sub | ~y & y_sub)).asUInt()
  val sel_double_negative = (y_add & ~y & ~y_sub).asUInt()
  val sel_double_positive = (~y_add & y & y_sub).asUInt()

  io.out:=Cat(sel_double_positive,sel_double_negative,sel_positive,sel_negative)
}

class gen_p extends Module{
  val io=IO(new Bundle{
    val src=Input(UInt(3.W))
    val x = Input(UInt(132.W))
    val p=Output(UInt(132.W))
    val c=Output(UInt(1.W))
  })

  val sel=Module(new gen_sel).io
  val p=Vec(132,Module(new gen_p_i).io)

  sel.src:=io.src
  for(i <- 0 to 132){
    p(i).x:= io.x(i)
    if(i>0){
      p(i).x_sub := io.x(i-1)
    }
    else{
      p(i).x_sub := 0.U
    }
    p(i).sel:=sel.out
  }
  
  io.p :=Cat(p.map(_.x.asUInt()))
  io.c :=sel.out(0) | sel.out(2)//-x or -2x
}

class switch extends Module{
  val io=IO(new Bundle{
    val in=Input(Vec(33,UInt(132.W)))
    val out=Output(Vec(132,UInt(33.W)))
  })
  for(j <- 0 until 132){
    val c = Wire(Vec(33,UInt(1.W)))
    for(i <- 0 until 33){
      c(i) := io.in(i)(j)
    }
    io.out(j) := c.asUInt
  }

  for(j <- 0 until 132)
    for(i <- 0 until 33){
      chisel3.assert(io.out(j)(i) === io.in(i)(j))
    }
}
//1 3 7 9 11 
class walloc_33bits extends Module{
  val io=IO(new Bundle{
    val src_in=Input(UInt(33.W))
    val cin= Input(UInt(30.W))
    val cout_group=Output(UInt(30.W))
    val cout=Output(UInt(1.W))
    val s=Output(UInt(1.W))
  })

  val c=Wire(UInt(30.W))
  ///////////////first////////////////
  val first_s = Wire(UInt(11.U))
  for(i <- Range(0,33,3).reverse){
    val csa(i) = Module(new CSA).io
    csa(i).in := Cat(io.src_in(i),io.src_in(i-1),io.src_in(i-2))
    Cat(c(n),first_s(n)) := csa(i).out
  }
}

class Walloc33bits extends Module {
  val io = IO(new Bundle {
    val src_in = Input(UInt(33.W))
    val cin = Input(UInt(30.W))
    val cout_group = Output(Vec(30, UInt(1.W)))
    val cout = Output(UInt(1.W))
    val s = Output(UInt(1.W))
  })

  val csa = Vec(31,Module(new CSA))
  val c = Wire(Vec(30, UInt(1.W)))
  // First
  val first_s = Wire(Vec(11, UInt(1.W)))
  for (i <- 0 t0 11) {
    csa(i).io.in := io.src_in(32 - i * 3, 30 - i * 3)
    Cat(c(10-i),first_s(10 - i)) := csa(i).io.out
  }

  // Second
  for(@@)
  for (i <- 0 to 9) {
    csa2(i).io.in := Cat(first_s(10 - i * 2), first_s(9 - i * 2), first_s(8 - i * 2), first_s(7 - i * 2), first_s(6 - i * 2), first_s(5 - i * 2), first_s(4 - i * 2), first_s(3 - i * 2), first_s(2 - i * 2))
  }

  // Third
  val csa3 = Seq.tabulate(7)(i => Module(new CSA))
  csa3(0).io.in := Cat(first_s(1), first_s(0), io.src_in(1), io.cin(4, 0))
  for (i <- 0 to 7) {
    csa3(i).io.in := Cat(first_s(1 - i), io.src_in(1 - i * 3), io.cin(4 - i * 3, 0 - i * 3))
  }

  // Fourth
  val csa4 = Seq.tabulate(3)(i => Module(new CSA))
  csa4(0).io.in := Cat(io.src_in(0), io.cin(9, 7))
  csa4(1).io.in := Cat(io.src_in(2), io.cin(12, 10))
  csa4(2).io.in := Cat(io.src_in(4), io.cin(15, 13))

  // Fifth
  val csa5 = Module(new CSA)
  csa5.io.in := Cat(io.src_in(6), io.cin(18, 16))

  // Output
  for (i <- 0 until 11) {
    io.cout_group(10 - i) := csa1(i).io.cout
  }
  for (i <- 11 until 20) {
    io.cout_group(19 - i) := csa2(i - 11).io.cout
  }
  for (i <- 20 until 27) {
    io.cout_group(26 - i) := csa3(i - 20).io.cout
  }
  io.cout_group(27) := csa3(6).io.cout
  io.cout_group(28) := csa4(0).io.cout
  io.cout_group(29) := csa4(1).io.cout
  io.cout_group(30) := csa4(2).io.cout
  io.cout_group(31) := csa5.io.cout

  // Cascade
  val csa_cascade = Module(new CSACascade)
  csa_cascade.io.in := Cat(io.cin(20, 19), io.s, io.cin(29, 21))
}
class Wallace extends Module{
  val io=IO(new Bundle{
      val mul_valid = Input(UInt(1.W))         //为高表示输入的数据有效，如果没有新的乘法输入，在乘法被接受的下一个周期要置低
      val flush= Input(UInt(1.W))              //为高表示取消乘法
      val mulw= Input(UInt(1.W))               //为高表示是 32 位乘法
      val mul_signed= Input(UInt(2.W))         //2’b11（signed x signed）；2’b10（signed x unsigned）；2’b00（unsigned x unsigned）；
      val multiplicand= Input(UInt(64.W))      //被乘数，64 表示乘法器位数
      val multiplier= Input(UInt(64.W))        //乘数
      val mul_ready= Output(UInt(1.W))         //为高表示乘法器准备好，表示可以输入数据
      val out_valid= Output(UInt(1.W))         //为高表示乘法器输出的结果有效
      val result_hi= Output(UInt(64.W))        //高 64 bits 结果
      val result_lo= Output(UInt(64.W))        //低 64 bits 结果
  })



}



object Wallace extends TestSuite {
  val tests: Tests = Tests {
    test("mytest") {
      new Formal with HasTestName {
        def getTestName: String = s"Wallace"
      }.verify(new switch, Seq(BoundedCheck(1)))
    }
  }
}


error stacktrace:
scala.collection.LinearSeqOps.apply(LinearSeq.scala:131)
	scala.collection.LinearSeqOps.apply$(LinearSeq.scala:128)
	scala.collection.immutable.List.apply(List.scala:79)
	dotty.tools.dotc.util.Signatures$.countParams(Signatures.scala:501)
	dotty.tools.dotc.util.Signatures$.applyCallInfo(Signatures.scala:186)
	dotty.tools.dotc.util.Signatures$.computeSignatureHelp(Signatures.scala:94)
	dotty.tools.dotc.util.Signatures$.signatureHelp(Signatures.scala:63)
	scala.meta.internal.pc.MetalsSignatures$.signatures(MetalsSignatures.scala:17)
	scala.meta.internal.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:51)
	scala.meta.internal.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:371)
