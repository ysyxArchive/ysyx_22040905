java.lang.IndexOutOfBoundsException: 0
occurred in the presentation compiler.

action parameters:
offset: 4956
uri: file://<WORKSPACE>/npc/playground/test/src/WallaceTest.scala
text:
import chisel3._
import chisel3.util._
import chiseltest._
import chisel3.experimental.BundleLiterals._
import chiseltest.formal._
import chiseltest.formal.BoundedCheck
import utest._

class HA extends Module{
  val io=IO(new Bundle{
    val in = Input(Vec(2,Bool()))
    val out = Output(Vec(2,Bool()))
  })

  io.out(1) := io.in(0) ^ io.in(1)  //cout
  io.out(0) := io.in(0) & io.out(1) //sum
  
}

class CSA extends Module{
  val io=IO(new Bundle{
    val in = Input(Vec(3,Bool()))
    val out = Output(Vec(2,Bool()))
  })

  io.out(1) := (io.in(0) & io.in(1)) | (io.in(2) & (io.in(0) ^ io.in(1))) //cout
  io.out(0) := io.in(0) ^ io.in(1) ^ io.in(2)                             //sum
}

class gen_p_i extends Module{
  val io=IO(new Bundle{
    val x=Input(Bool())
    val x_sub=Input(Bool())
    val sel=Input(UInt(4.W))
    val p=Output(Bool())
  })
  val sel_negative=io.sel(0)
  val sel_positive=io.sel(1)
  val sel_double_negative=io.sel(2)
  val sel_double_positive=io.sel(3)

  io.p := ~(~(sel_negative & ~io.x) & ~(sel_double_negative & ~io.x_sub) 
          & ~(sel_positive & io.x ) & ~(sel_double_positive &  io.x_sub));
}

class gen_sel extends Module {
  val io = IO(new Bundle {
    val src = Input(UInt(3.W))
    val out=Output(UInt(4.W))
  })

  val y_sub = io.src(0)
  val y =io.src(1)
  val y_add =io.src(2)

  val sel_negative = (y_add & (y & ~y_sub | ~y & y_sub)).asUInt()
  val sel_positive = (~y_add & (y & ~y_sub | ~y & y_sub)).asUInt()
  val sel_double_negative = (y_add & ~y & ~y_sub).asUInt()
  val sel_double_positive = (~y_add & y & y_sub).asUInt()

  io.out:=Cat(sel_double_positive,sel_double_negative,sel_positive,sel_negative)
}

class gen_p extends Module{
  val io=IO(new Bundle{
    val src=Input(UInt(3.W))
    val x = Input(UInt(132.W))
    val p=Output(UInt(132.W))
    val c=Output(UInt(1.W))
  })

  val sel=Module(new gen_sel).io
  val p=Vec(132,Module(new gen_p_i).io)

  sel.src:=io.src
  for(i <- 0 to 132){
    p(i).x:= io.x(i)
    if(i>0){
      p(i).x_sub := io.x(i-1)
    }
    else{
      p(i).x_sub := 0.U
    }
    p(i).sel:=sel.out
  }
  
  io.p :=Cat(p.map(_.x.asUInt()))
  io.c :=sel.out(0) | sel.out(2)//-x or -2x
}

class switch extends Module{
  val io=IO(new Bundle{
    val in=Input(Vec(33,UInt(132.W)))
    val out=Output(Vec(132,UInt(33.W)))
    val cin=Input(Vec(33,UInt(1.W)))
    val cout=Output(UInt(32.W))
  })
  for(j <- 0 until 132){
    val c = Wire(Vec(33,UInt(1.W)))
    for(i <- 0 until 33){
      c(i) := io.in(i)(j)
    }
    io.out(j) := c.asUInt
  }

  for(j <- 0 until 132)
    for(i <- 0 until 33){
      chisel3.assert(io.out(j)(i) === io.in(i)(j))
    }

  io.cout:=io.cin.asUInt(31,0)
}
//1 3 7 9 11 
class Walloc33bits extends Module {
  val io = IO(new Bundle {
    val src_in = Input(UInt(33.W))
    val cin = Input(UInt(30.W))
    val cout_group = Output(Vec(30, UInt(1.W)))
    val cout = Output(UInt(1.W))
    val s = Output(UInt(1.W))
  })

  val cin = io.cin
  val csa =  Seq.fill(31)(Module(new CSA))
  val c = Wire(Vec(30, UInt(1.W)))
  // First
  val first_s = Wire(Vec(11, UInt(1.W)))
  for (i <- 0 to 11){
    csa(i).io.in := io.src_in(32 - i * 3, 30 - i * 3)
    Cat(c(10-i),first_s(10 - i)) := csa(i).io.out
  }

  // Second
  val second_s = Wire(Vec(11, UInt(1.W)))
    csa(11).io.in := first_s.asUInt(10,8)
    csa(12).io.in := first_s.asUInt(7,5)
    csa(13).io.in := first_s.asUInt(4,2)
    csa(14).io.in := Cat(first_s.asUInt(1,0),cin(15))
    csa(15).io.in := cin(14,12)
    csa(16).io.in := cin(11,9)
    csa(17).io.in := cin(8,6)
    csa(18).io.in := cin(5,3)
    csa(19).io.in := cin(2,0)
   
  for(i <- 0 to 9){
    Cat(c(19 - i),second_s(9 - i)) := csa(i+11).io.out
  }

  // Third

  val third_s = Wire(Vec(7, UInt(1.W)))

    csa(20).io.in:= second_s.asUInt(8,6)
    csa(21).io.in:= second_s.asUInt(5,3)
    csa(22).io.in:= second_s.asUInt(2,0)
    csa(23).io.in:= cin(27,25)
    csa(24).io.in:= cin(24,22)
    csa(25).io.in:= cin(21,19)
    csa(26).io.in:= cin(18,16)

  for (i <- 0 to 7) {
    Cat(c(27 - i),third_s(7 - i)) := csa(i+20).io.out
  }
   
 

  // Fourth
  val fourth_s = Wire(Vec(3, UInt(1.W)))
  csa(27).io.in := third_s.asUInt(6,4)
  csa(28).io.in := third_s.asUInt(3,1)
  csa(29).io.in := Cat(third_s.asUInt(0), cin(29,28))

  for(i <- 0 to 3){
    Cat(c(30 - i),fourth_s(3 - i)) := csa(i+27).io.out
  }

  // Fifth
  val fifth = Wire(Vec(1, UInt(1.W)))
  csa(30).io.in := fourth_s.asUInt(2,0)
  Cat(io.cout,io.s) := csa(30).io.out

  io.cout_group := c

}

class walloc_64_mul extends Module{
val io=IO( new Bundle{
    val multiplicand= Input(UInt(132.W))       
    val multiplier= Input(UInt(66.W))        
    val result = Output(UInt(128.W))
    val mul_valid = Input(UInt(1.W))
  })

  val mula = RegEnalbe(io.multiplicand,0.U(132.W),io.mul_valid)
  val mulb = RegEnalbe(Cat(io.multiplier,0.U),0.U(67.W),io.mul_valid)
  val gp= Seq.fill(33)(Module(new gen_p)).io
  val sw=Module(new switch).io
  val wa=Seq.fill(132)(*@@Module(new Walloc33bits).io

  val p = Wire(Vec(132,UInt(1.W)))
  val c = Wire(Vec(132,UInt(1.W)))

  for(i <- 0 to 33){
    gp(i).src:=mulb(2+2*i,2*i)
    gp(i).x:=mula
    sw.in(i):=gp(i).p  
    sw.cin(i):=gp(i).c  
  }


  for(i <- 0 to 132){

  }

}
class Wallace extends Module{
  val io=IO(new Bundle{
      val mul_valid = Input(UInt(1.W))         //为高表示输入的数据有效，如果没有新的乘法输入，在乘法被接受的下一个周期要置低
      val flush= Input(UInt(1.W))              //为高表示取消乘法
      val mulw= Input(UInt(1.W))               //为高表示是 32 位乘法
      val mul_signed= Input(UInt(2.W))         //2’b11（signed x signed）；2’b10（signed x unsigned）；2’b00（unsigned x unsigned）；
      val multiplicand= Input(UInt(64.W))      //被乘数，64 表示乘法器位数
      val multiplier= Input(UInt(64.W))        //乘数
      val mul_ready= Output(UInt(1.W))         //为高表示乘法器准备好，表示可以输入数据
      val out_valid= Output(UInt(1.W))         //为高表示乘法器输出的结果有效
      val result_hi= Output(UInt(64.W))        //高 64 bits 结果
      val result_lo= Output(UInt(64.W))        //低 64 bits 结果
  })



}



object Wallace extends TestSuite {
  val tests: Tests = Tests {
    test("mytest") {
      new Formal with HasTestName {
        def getTestName: String = s"Wallace"
      }.verify(new switch, Seq(BoundedCheck(1)))
    }
  }
}


error stacktrace:
scala.collection.LinearSeqOps.apply(LinearSeq.scala:131)
	scala.collection.LinearSeqOps.apply$(LinearSeq.scala:128)
	scala.collection.immutable.List.apply(List.scala:79)
	dotty.tools.dotc.util.Signatures$.countParams(Signatures.scala:501)
	dotty.tools.dotc.util.Signatures$.applyCallInfo(Signatures.scala:186)
	dotty.tools.dotc.util.Signatures$.computeSignatureHelp(Signatures.scala:94)
	dotty.tools.dotc.util.Signatures$.signatureHelp(Signatures.scala:63)
	scala.meta.internal.pc.MetalsSignatures$.signatures(MetalsSignatures.scala:17)
	scala.meta.internal.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:51)
	scala.meta.internal.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:371)
